## 递归 Recursion

递归是分解的过程，去的过程叫"递"，回来的过程叫"归"。基本上所有的递归问题都可以用递推公式改为递归代码。

### 递归解决问题的三个条件

1. 一个问题的解可以分解为几个子问题的解

2. 这个问题与分解之后的子问题，除子数据规模不同，求解思路完全一样

3. 存在递归终止条件

### 递归代码

写递归代码最关键是写出递推公式，找到终止条件，剩下的将递推公式转化为代码就行了。递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写子递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

### 递归重复计算

递归代码会出现重复计算问题，为了避免重复计算，我们可以通过一个数据结构(比如散列表)，来保存已经求解过的 **f(k)**,当调用到 **f(k)**时，可以先看看散列表中有没有计算过，计算过直接取值，不需要重复计算，没计算过计算并保存值。

递归空间复杂度 **O(n)**
递归时间复杂度 **O(n)**

### 递归优缺点

递归有利有弊
优点，是递归代码的表达力很强，写起来非常简洁
缺点，就是空间复杂度高，有堆栈溢出的风险，存在重复计算，过多的函数调用会耗时较多的问题。

递归改成迭代循环的非递归写法,即 **DP 动态规划**。
递归本身就是借助 栈来实现的，只不过我们使用栈是系统或虚拟机本身提供的，如果我们在内存堆上实现栈，手动模拟入栈，出栈过程，这样任何递归代码都可以写成看上去不是递归代码的样子。


